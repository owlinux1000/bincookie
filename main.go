package main

import (
    "os"
    "fmt"
    "bytes"
    "encoding/binary"
)

const Header = `# Netscape HTTP Cookie File
# This file was generated by owlinux1000's iOSCookiReader
# https://github.com/owlinux1000/iOSCookieReader
`

func main() {

    if len(os.Args) != 2 {
        fmt.Fprintf(os.Stderr, "Usage: eat-cookie <FILE.binarycookies>")
        os.Exit(0)
    }
    
    file, err := os.Open(os.Args[1])
    if err != nil {
        fmt.Fprintf(os.Stderr, "%s", err)
        os.Exit(1)
    }
    defer file.Close()

    // Check whether the magic number is "cook"
    magic_number := make([]byte, 4)
    file.Read(magic_number)
    if string(magic_number) != "cook" {
        fmt.Fprintln(os.Stderr, "The magic number has unexpected.")
        os.Exit(1)
    }

    // Read number of pages 
    var num_pages uint32
    binary.Read(file, binary.BigEndian, &num_pages)

    // Read the each page size
    page_sizes := []uint32{}
    for i := uint32(0); i < num_pages; i++ {
        var page_size uint32
        binary.Read(file, binary.BigEndian, &page_size)
        page_sizes = append(page_sizes, page_size)
    }

    pages := [][]byte{}
    for _, v := range page_sizes {
        page_buf := make([]byte, v)
        file.Read(page_buf)
        pages = append(pages, page_buf)
    }

    fmt.Println(Header)
    for _, v := range pages {
        
        buf := bytes.NewReader(v)
        
        var page_header uint32
        binary.Read(buf, binary.BigEndian, &page_header)
        if page_header != 0x100 {
            fmt.Fprintln(os.Stderr, "The page header has unexpected.")
            os.Exit(1)
        }
        
        var num_cookies uint32
        binary.Read(buf, binary.LittleEndian, &num_cookies)
        cookie_offsets := []int64{}
        for i := uint32(0); i < num_cookies; i++ {
            var cookie_offset int32
            binary.Read(buf, binary.LittleEndian, &cookie_offset)
            cookie_offsets = append(
                cookie_offsets,
                int64(cookie_offset),
            )
        }
        
        var page_footer uint32
        binary.Read(buf, binary.LittleEndian, page_footer)
        if page_footer != 0x0 {
            fmt.Fprintln(os.Stderr, "The page footer has unexpected.")
            os.Exit(1)
        }

        for _, v := range cookie_offsets {

            buf.Seek(v, os.SEEK_SET)
            
            var cookie_size uint32
            binary.Read(buf, binary.LittleEndian, &cookie_size)
            
            cookie := make([]byte, cookie_size)
            buf.Read(cookie)
            buf_cookie := bytes.NewReader(cookie)

            // Skip 4 bytes that is unknown
            buf_cookie.Seek(4, os.SEEK_CUR)
            
            var flags uint32
            binary.Read(buf_cookie, binary.LittleEndian, &flags)

            // Skip 4 bytes that is unknown
            buf_cookie.Seek(4, os.SEEK_CUR)

            var url_offset uint32
            binary.Read(buf_cookie, binary.LittleEndian, &url_offset)
            
            var name_offset uint32
            binary.Read(buf_cookie, binary.LittleEndian, &name_offset)

            var path_offset uint32
            binary.Read(buf_cookie, binary.LittleEndian, &path_offset)

            var value_offset uint32
            binary.Read(buf_cookie, binary.LittleEndian, &value_offset)

            // Skip 8 bytes that is the end of cookie
            buf_cookie.Seek(8, os.SEEK_CUR)

            var expiry_date_epoch float64
            binary.Read(buf_cookie, binary.LittleEndian, &expiry_date_epoch)
            expiry_date_epoch += 978307200

            var create_date_epoch float64
            binary.Read(buf_cookie, binary.LittleEndian, &create_date_epoch)
            create_date_epoch += 978307200
            
            domain := readString(buf_cookie)
            cookie_name := readString(buf_cookie)
            path := readString(buf_cookie)
            cookie_value := readString(buf_cookie)

            if flags == 5 || flags == 4 {
                fmt.Printf("#HttpOnly_")
            }
            fmt.Printf("%s\t", domain)
            if domain[0] == 46 {
                fmt.Printf("TRUE\t")
            } else {
                fmt.Printf("FALSE\t")
            }
            fmt.Printf("%s\t", path)
            if flags == 1 || flags == 5 {
                fmt.Printf("TRUE\t")
            } else {
                fmt.Printf("FALSE\t")
            }
            fmt.Printf("%d\t%s\t%s\n", int(expiry_date_epoch), cookie_name, cookie_value)
        }
    }
    
}

func readString(reader *bytes.Reader) (buffer []byte) {
    for ;; {
        buf := make([]byte, 1)
        reader.Read(buf)
        if buf[0] == 0x0{
            break
        }
        buffer = append(buffer, buf[0])
    }
    return buffer
}
